/**
 * Office Script — Customer Retention fetcher (Option 2)
 * Returns retention as a number (0–100) + metadata, ideal for Power Automate.
 *
 * Supported sources (first match wins):
 *  1) Named range: RetentionPct
 *  2) Table: tblKPIs with columns Metric + Value (Metric row = "Customer Retention")
 *  3) Fallback cell: KPIs!B2
 */

type RetentionResult = {
  retention: number | null;           // 0..100 (integer) or null if not found/invalid
  status: "ok" | "not_found" | "invalid";
  source: string;
  message?: string;
  updatedAtLocal?: string;            // optional timestamp (written if you enable logging)
};

// ---- CONFIG (edit if you want) ----
const NAMED_RANGE = "RetentionPct";
const TABLE_NAME = "tblKPIs";
const TABLE_COL_METRIC = "Metric";
const TABLE_COL_VALUE = "Value";
const TABLE_METRIC_MATCH = "Customer Retention";
const FALLBACK_SHEET = "KPIs";
const FALLBACK_CELL = "B2";

// Optional logging: set to true to write a timestamp + last value somewhere
const ENABLE_LOGGING = false;
const LOG_SHEET = "KPIs";
const LOG_CELL_VALUE = "D2"; // writes numeric retention
const LOG_CELL_TIME = "D3";  // writes timestamp

export default function main(workbook: ExcelScript.Workbook): RetentionResult {
  // 1) Try named range
  const fromNamed = tryGetFromNamedRange(workbook, NAMED_RANGE);
  if (fromNamed) return finalize(workbook, fromNamed);

  // 2) Try table lookup
  const fromTable = tryGetFromTable(workbook, TABLE_NAME, TABLE_COL_METRIC, TABLE_COL_VALUE, TABLE_METRIC_MATCH);
  if (fromTable) return finalize(workbook, fromTable);

  // 3) Fallback cell
  const fromCell = tryGetFromCell(workbook, FALLBACK_SHEET, FALLBACK_CELL);
  if (fromCell) return finalize(workbook, fromCell);

  return {
    retention: null,
    status: "not_found",
    source: "none",
    message: `Couldn't find retention value in named range '${NAMED_RANGE}', table '${TABLE_NAME}', or ${FALLBACK_SHEET}!${FALLBACK_CELL}.`
  };
}

// ---------- Helpers ----------

function tryGetFromNamedRange(workbook: ExcelScript.Workbook, rangeName: string): RetentionResult | null {
  try {
    const named = workbook.getNamedItem(rangeName);
    const rng = named.getRange();
    const v = rng.getValue();
    const parsed = parseRetention(v);

    if (parsed.status === "ok") {
      return { ...parsed, source: `NamedRange:${rangeName}` };
    }
    return { ...parsed, source: `NamedRange:${rangeName}` };
  } catch {
    return null; // named range not found
  }
}

function tryGetFromTable(
  workbook: ExcelScript.Workbook,
  tableName: string,
  metricCol: string,
  valueCol: string,
  metricMatch: string
): RetentionResult | null {
  let table: ExcelScript.Table;
  try {
    table = workbook.getTable(tableName);
  } catch {
    return null; // table not found
  }

  const headerRange = table.getHeaderRowRange();
  const headers = headerRange.getValues()[0].map(h => String(h).trim());

  const metricIdx = headers.findIndex(h => equalsLoose(h, metricCol));
  const valueIdx = headers.findIndex(h => equalsLoose(h, valueCol));
  if (metricIdx < 0 || valueIdx < 0) {
    return {
      retention: null,
      status: "invalid",
      source: `Table:${tableName}`,
      message: `Table '${tableName}' must have columns '${metricCol}' and '${valueCol}'. Found: ${headers.join(", ")}`
    };
  }

  const body = table.getDataBodyRange();
  if (!body) {
    return {
      retention: null,
      status: "not_found",
      source: `Table:${tableName}`,
      message: `Table '${tableName}' has no rows.`
    };
  }

  const rows = body.getValues();
  for (let r = 0; r < rows.length; r++) {
    const metric = String(rows[r][metricIdx]).trim();
    if (equalsLoose(metric, metricMatch)) {
      const parsed = parseRetention(rows[r][valueIdx]);
      return { ...parsed, source: `Table:${tableName} (Metric='${metricMatch}')` };
    }
  }

  return {
    retention: null,
    status: "not_found",
    source: `Table:${tableName}`,
    message: `No row found where '${metricCol}' equals '${metricMatch}'.`
  };
}

function tryGetFromCell(workbook: ExcelScript.Workbook, sheetName: string, address: string): RetentionResult | null {
  try {
    const ws = workbook.getWorksheet(sheetName);
    const v = ws.getRange(address).getValue();
    const parsed = parseRetention(v);
    return { ...parsed, source: `Cell:${sheetName}!${address}` };
  } catch {
    return null; // sheet/cell not found
  }
}

/**
 * Accepts:
 *  - 93
 *  - 0.93 (interpreted as 93%)
 *  - "93%"
 *  - "93"
 */
function parseRetention(value: ExcelScript.RangeValueType): RetentionResult {
  if (value === null || value === undefined || value === "") {
    return { retention: null, status: "invalid", source: "parse", message: "Retention value is blank." };
  }

  // If it's a string like "93%" or "93"
  if (typeof value === "string") {
    const s = value.trim();
    const cleaned = s.endsWith("%") ? s.slice(0, -1).trim() : s;
    const n = Number(cleaned);
    if (!Number.isFinite(n)) {
      return { retention: null, status: "invalid", source: "parse", message: `Retention value '${value}' is not numeric.` };
    }
    return validateAndNormalize(n, `Parsed from string '${value}'`);
  }

  // If it's numeric
  if (typeof value === "number") {
    return validateAndNormalize(value, "Parsed from number");
  }

  // Booleans etc.
  return { retention: null, status: "invalid", source: "parse", message: `Unsupported value type: ${typeof value}` };
}

function validateAndNormalize(n: number, msg: string): RetentionResult {
  // If user stored as decimal (0.93), treat as 93
  const normalized = (n > 0 && n <= 1) ? n * 100 : n;

  if (!Number.isFinite(normalized)) {
    return { retention: null, status: "invalid", source: "validate", message: "Value is not finite." };
  }

  // Allow slight float weirdness
  const rounded = Math.round(normalized);

  if (rounded < 0 || rounded > 100) {
    return { retention: null, status: "invalid", source: "validate", message: `${msg}. Value ${normalized} out of range (0–100).` };
  }

  return { retention: rounded, status: "ok", source: "validate" };
}

function finalize(workbook: ExcelScript.Workbook, result: RetentionResult): RetentionResult {
  // Add local timestamp (Excel will store as string)
  const now = new Date();
  const updatedAtLocal = now.toLocaleString();

  const out: RetentionResult = { ...result, updatedAtLocal };

  if (ENABLE_LOGGING && out.retention !== null) {
    try {
      const ws = workbook.getWorksheet(LOG_SHEET);
      ws.getRange(LOG_CELL_VALUE).setValue(out.retention);
      ws.getRange(LOG_CELL_TIME).setValue(updatedAtLocal);
    } catch {
      // ignore logging failures
    }
  }

  return out;
}

function equalsLoose(a: string, b: string): boolean {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}
