/**
 * Office Script — Customer Retention Fetcher (v2.0)
 * Returns retention as a number (0–100) + metadata, ideal for Power Automate.
 *
 * Supported sources (first match wins):
 *  1) Named range: RetentionPct
 *  2) Table: MyKPITable with columns Metric + Value (Metric row = "Customer Retention")
 *  3) Fallback cell: KPIs!B2
 *
 * @author Office Scripts
 * @version 2.0.0
 */

/** Retention fetch result type */
type RetentionResult = {
  /** Retention value from 0-100 (integer) or null if not found/invalid */
  retention: number | null;
  /** Status of the fetch operation */
  status: "ok" | "not_found" | "invalid";
  /** Source location where the value was found */
  source: string;
  /** Optional error or informational message */
  message?: string;
  /** Optional timestamp of when the value was fetched (ISO 8601 format) */
  updatedAtLocal?: string;
  /** Optional percent string (exact, unrounded) like "93.2%" */
  percentText?: string;
};

/** Excel value type (compatible with Office Scripts) */
type CellValue = string | number | boolean;

/** Minimal ExcelScript type declarations for local compile-time only */
declare namespace ExcelScript { interface Workbook {} }

/**
 * Workbook type alias removed; using ExcelScript.Workbook in signatures
 */

// Minimal structural interfaces for Office Scripts runtime (no explicit 'any')
interface OSRange {
  getValue(): CellValue | null | undefined;
  setValue(v: unknown): void;
  getValues(): unknown[][];
}
interface OSNamedItem {
  getRange(): OSRange | null;
}
interface OSTable {
  getHeaderRowRange(): OSRange | null;
  getDataBodyRange(): OSRange | null;
}
interface OSWorksheet {
  getRange(address: string): OSRange | null;
  activate(): void;
  getName(): string;
}
interface OSWorkbook {
  getNamedItem(name: string): OSNamedItem | null;
  getTable(name: string): OSTable | null;
  getWorksheet(name: string): OSWorksheet | null;
  addWorksheet(name: string): OSWorksheet;
  getActiveWorksheet(): OSWorksheet;
}

// ========== CONFIGURATION ==========
/** Named range to check for retention value */
const NAMED_RANGE = "RetentionPct" as const;

/** Table name to search for retention metric */
const TABLE_NAME = "MyKPITable" as const;

/** Table column containing metric names */
const TABLE_COL_METRIC = "Metric" as const;

/** Table column containing metric values */
const TABLE_COL_VALUE = "Value" as const;

/** Metric name to match in table */
const TABLE_METRIC_MATCH = "Customer Retention" as const;

/** Fallback sheet name */
const FALLBACK_SHEET = "KPIs" as const;

/** Fallback cell address */
const FALLBACK_CELL = "B2" as const;

/** Enable logging to worksheet */
const ENABLE_LOGGING = true as const;

/** Sheet for logging (if enabled) */
const LOG_SHEET = "Where We Are" as const;
/** Log to the active sheet only (ignores LOG_SHEET) */
const LOG_TO_ACTIVE_SHEET_ONLY = true as const;

/** Cell to log retention value */
const LOG_CELL_VALUE = "D2" as const;

/** Cell to log timestamp */
const LOG_CELL_TIME = "D3" as const;
/** Cell to log percent text */
const LOG_CELL_PERCENT = "D4" as const;

// ========== DIAGNOSTICS CONFIG ==========
/** Enable lightweight diagnostics (console logging) */
const ENABLE_DIAGNOSTICS = true as const;
/** Also write diagnostics to a sheet (optional) */
const DIAG_WRITE_TO_SHEET = true as const;
/** Diagnostics sheet and starting cell when writing */
const DIAG_SHEET = "Where We Are" as const;
const DIAG_START_CELL = "E2" as const;

// ========== MAIN FUNCTION ==========

/**
 * Main entry point for the Office Script.
 * Attempts to fetch customer retention from multiple sources in priority order.
 *
 * @param workbook - The Excel workbook object
 * @returns RetentionResult object with retention value and metadata
 */
function main(workbook: ExcelScript.Workbook): RetentionResult {
  diag(workbook, [
    `Script started: logging=${ENABLE_LOGGING ? "on" : "off"}, logSheet='${LOG_SHEET}', diagSheet='${DIAG_SHEET}'`
  ]);
  // Validate workbook parameter
  if (!workbook) {
    return {
      retention: null,
      status: "invalid",
      source: "none",
      message: "Invalid workbook object provided."
    };
  }

  // 1) Try named range
  const fromNamed = tryGetFromNamedRange(workbook, NAMED_RANGE);
  if (fromNamed) {
    diag(workbook, [
      `Named range '${NAMED_RANGE}' found`,
      `Result: status=${fromNamed.status}, retention=${fromNamed.retention}`
    ]);
    return finalize(workbook, fromNamed);
  }

  // 2) Try table lookup
  const fromTable = tryGetFromTable(
    workbook,
    TABLE_NAME,
    TABLE_COL_METRIC,
    TABLE_COL_VALUE,
    TABLE_METRIC_MATCH
  );
  if (fromTable) {
    diag(workbook, [
      `Table '${TABLE_NAME}' lookup matched '${TABLE_METRIC_MATCH}'`,
      `Result: status=${fromTable.status}, retention=${fromTable.retention}`
    ]);
    return finalize(workbook, fromTable);
  }

  // 3) Fallback cell
  const fromCell = tryGetFromCell(workbook, FALLBACK_SHEET, FALLBACK_CELL);
  if (fromCell) {
    diag(workbook, [
      `Fallback cell ${FALLBACK_SHEET}!${FALLBACK_CELL} used`,
      `Result: status=${fromCell.status}, retention=${fromCell.retention}`
    ]);
    return finalize(workbook, fromCell);
  }

  // Nothing found — finalize to ensure logging still occurs
  return finalize(workbook, {
    retention: null,
    status: "not_found",
    source: "none",
    message: `Retention value not found. Checked: Named range '${NAMED_RANGE}', Table '${TABLE_NAME}', and Cell ${FALLBACK_SHEET}!${FALLBACK_CELL}.`
  });
}

// ========== HELPER FUNCTIONS ==========

/**
 * Attempts to retrieve retention from a named range.
 *
 * @param workbook - The Excel workbook
 * @param rangeName - Name of the range to check
 * @returns RetentionResult if found, null otherwise
 */
function tryGetFromNamedRange(
  workbook: ExcelScript.Workbook,
  rangeName: string
): RetentionResult | null {
  try {
    const wb = workbook as unknown as OSWorkbook;
    const namedItem = wb.getNamedItem(rangeName);
    
    // Check if named range exists
    if (!namedItem) {
      return null;
    }

    let range: OSRange | null = null;
    try {
      range = namedItem.getRange();
    } catch (e) {
      diag(workbook, [
        `Named item '${rangeName}' getRange() threw: ${String((e as Error).message || e)}`,
        `Tip: Ensure '${rangeName}' refers to a cell/range reference, not only a formula.`
      ]);
      return null;
    }
    if (!range) {
      return null;
    }

    const value: CellValue | null | undefined = range.getValue();
    const parsed: RetentionResult = parseRetention(value);
    diag(workbook, [
      `Named '${rangeName}' raw='${String(value)}', parsed=${parsed.retention} (${parsed.status})`
    ]);

    return {
      ...parsed,
      source: `NamedRange:${rangeName}`
    };
  } catch (error) {
    diag(workbook, [
      `Error accessing named range '${rangeName}': ${String(error)}`
    ]);
    // Named range not found or error accessing it
    return null;
  }
}

/**
 * Attempts to retrieve retention from a table by searching for a metric row.
 *
 * @param workbook - The Excel workbook
 * @param tableName - Name of the table to search
 * @param metricCol - Column name containing metric names
 * @param valueCol - Column name containing metric values
 * @param metricMatch - Metric name to search for
 * @returns RetentionResult if found, null otherwise
 */
function tryGetFromTable(
  workbook: ExcelScript.Workbook,
  tableName: string,
  metricCol: string,
  valueCol: string,
  metricMatch: string
): RetentionResult | null {
  try {
    const wb = workbook as unknown as OSWorkbook;
    const table = wb.getTable(tableName);
    diag(workbook, [
      table ? `Table '${tableName}' found` : `Table '${tableName}' NOT found`
    ]);
    
    // Check if table exists
    if (!table) {
      return null;
    }

    let headerRange: OSRange | null = null;
    try {
      headerRange = table.getHeaderRowRange();
    } catch (e) {
      diag(workbook, [
        `Table '${tableName}' getHeaderRowRange() threw: ${String((e as Error).message || e)}`,
        `Tip: Ensure '${tableName}' is an Excel Table (Insert > Table) with a header row.`
      ]);
      return {
        retention: null,
        status: "invalid",
        source: `Table:${tableName}`,
        message: `Cannot access header row. Verify '${tableName}' is a proper Excel Table with headers.`
      };
    }
    if (!headerRange) {
      diag(workbook, [
        `Header row missing in table '${tableName}'`
      ]);
      return {
        retention: null,
        status: "invalid",
        source: `Table:${tableName}`,
        message: `Table '${tableName}' has no header row.`
      };
    }

    const headerValues: unknown[][] = headerRange.getValues();
    if (!headerValues || headerValues.length === 0) {
      diag(workbook, [
        `Header row empty in table '${tableName}'`
      ]);
      return {
        retention: null,
        status: "invalid",
        source: `Table:${tableName}`,
        message: `Table '${tableName}' header row is empty.`
      };
    }

    const headers: string[] = headerValues[0].map((h: unknown) => String(h ?? "").trim());
    diag(workbook, [
      `Headers: [${headers.join(", ")}]`
    ]);

    // Find column indices
    const metricIdx: number = headers.findIndex((h: string) => equalsLoose(h, metricCol));
    const valueIdx: number = headers.findIndex((h: string) => equalsLoose(h, valueCol));
    diag(workbook, [
      `metricIdx=${metricIdx}, valueIdx=${valueIdx}`
    ]);

    if (metricIdx < 0 || valueIdx < 0) {
      return {
        retention: null,
        status: "invalid",
        source: `Table:${tableName}`,
        message: `Table '${tableName}' must have columns '${metricCol}' and '${valueCol}'. Found: [${headers.join(", ")}]`
      };
    }

    // Get table body
    let bodyRange: OSRange | null = null;
    try {
      bodyRange = table.getDataBodyRange();
    } catch (e) {
      diag(workbook, [
        `Table '${tableName}' getDataBodyRange() threw: ${String((e as Error).message || e)}`,
        `Tip: Ensure '${tableName}' is an Excel Table with data rows.`
      ]);
      return {
        retention: null,
        status: "invalid",
        source: `Table:${tableName}`,
        message: `Cannot access table rows. Verify '${tableName}' contains data rows.`
      };
    }
    if (!bodyRange) {
      diag(workbook, [
        `No data body range in table '${tableName}'`
      ]);
      return {
        retention: null,
        status: "not_found",
        source: `Table:${tableName}`,
        message: `Table '${tableName}' has no data rows.`
      };
    }

    const rows: unknown[][] = bodyRange.getValues();
    diag(workbook, [
      `Row count: ${rows.length}`,
      ...rows.slice(0, 5).map((r, i) => `r${i + 2}: metric='${String(r[metricIdx] ?? "").trim()}', value='${String(r[valueIdx] ?? "").trim()}'`)
    ]);
    
    // Search for matching metric row
    for (let rowIndex: number = 0; rowIndex < rows.length; rowIndex++) {
      const metricValue: string = String(rows[rowIndex][metricIdx] ?? "").trim();
      
      if (equalsLoose(metricValue, metricMatch)) {
        const cellValue: CellValue | null | undefined = rows[rowIndex][valueIdx] as CellValue | null | undefined;
        const parsed: RetentionResult = parseRetention(cellValue);
        diag(workbook, [
          `Match at row ${rowIndex + 2}: '${metricMatch}', valueRaw='${cellValue}', parsed=${parsed.retention} (${parsed.status})`
        ]);
        
        return {
          ...parsed,
          source: `Table:${tableName} (row ${rowIndex + 2}, Metric='${metricMatch}')`
        };
      }
    }

    // Metric not found in table
    return {
      retention: null,
      status: "not_found",
      source: `Table:${tableName}`,
      message: `No row found where '${metricCol}' equals '${metricMatch}' (case-insensitive).`
    };
  } catch (error) {
    diag(workbook, [
      `Error accessing table '${tableName}': ${String(error)}`
    ]);
    // Table not found or error accessing it
    return null;
  }
}

/**
 * Attempts to retrieve retention from a specific cell.
 *
 * @param workbook - The Excel workbook
 * @param sheetName - Name of the worksheet
 * @param address - Cell address (e.g., "B2")
 * @returns RetentionResult if found, null otherwise
 */
function tryGetFromCell(
  workbook: ExcelScript.Workbook,
  sheetName: string,
  address: string
): RetentionResult | null {
  try {
    const wb = workbook as unknown as OSWorkbook;
    const worksheet = wb.getWorksheet(sheetName);
    
    if (!worksheet) {
      return null;
    }

    let range: OSRange | null = null;
    try {
      range = worksheet.getRange(address);
    } catch (e) {
      diag(workbook, [
        `Worksheet '${sheetName}' getRange('${address}') threw: ${String((e as Error).message || e)}`,
        `Tip: Confirm sheet '${sheetName}' exists and address '${address}' is valid.`
      ]);
      return null;
    }
    if (!range) {
      return null;
    }

    const value: CellValue | null | undefined = range.getValue();
    const parsed: RetentionResult = parseRetention(value);

    return {
      ...parsed,
      source: `Cell:${sheetName}!${address}`
    };
  } catch (error) {
    const e = error as { name?: string; message?: string };
    diag(workbook, [
      `Error accessing cell ${sheetName}!${address}: ${e?.name ?? "Error"} ${e?.message ?? String(error)}`
    ]);
    // Sheet or cell not found
    return null;
  }
}

/**
 * Parses a retention value from various formats.
 * Accepts: 93, 0.93 (as 93%), "93%", "93"
 *
 * @param value - The cell value to parse
 * @returns RetentionResult with parsed value or error
 */
function parseRetention(value: CellValue | null | undefined): RetentionResult {
  // Handle null, undefined, or empty values
  if (value === null || value === undefined || value === "") {
    return {
      retention: null,
      status: "invalid",
      source: "parse",
      message: "Retention value is blank or empty."
    };
  }

  // Handle boolean values (not valid for retention)
  if (typeof value === "boolean") {
    return {
      retention: null,
      status: "invalid",
      source: "parse",
      message: `Boolean value '${value}' is not valid for retention.`
    };
  }

  // Handle string values (e.g., "93%", "93", "0.93")
  if (typeof value === "string") {
    const trimmed: string = value.trim();
    
    // Handle percentage strings
    const cleaned: string = trimmed.endsWith("%") 
      ? trimmed.slice(0, -1).trim() 
      : trimmed;

    const numericValue: number = Number(cleaned);

    if (!Number.isFinite(numericValue)) {
      return {
        retention: null,
        status: "invalid",
        source: "parse",
        message: `String value '${value}' cannot be converted to a number.`
      };
    }

    return validateAndNormalize(numericValue, `string '${value}'`);
  }

  // Handle numeric values
  if (typeof value === "number") {
    return validateAndNormalize(value, "number");
  }

  // Unsupported type
  return {
    retention: null,
    status: "invalid",
    source: "parse",
    message: `Unsupported value type: ${typeof value}`
  };
}

/**
 * Validates and normalizes a numeric retention value to 0-100 range.
 * Converts decimals (0.93) to percentages (93).
 *
 * @param numericValue - The numeric value to validate
 * @param sourceDescription - Description of the source for error messages
 * @returns RetentionResult with validated value or error
 */
function validateAndNormalize(
  numericValue: number,
  sourceDescription: string
): RetentionResult {
  // Check for non-finite values (NaN, Infinity)
  if (!Number.isFinite(numericValue)) {
    return {
      retention: null,
      status: "invalid",
      source: "validate",
      message: `Value from ${sourceDescription} is not a finite number.`
    };
  }

  // Convert decimal to percentage (0.93 → 93). Keep exact normalized for percent string
  const normalized: number = (numericValue > 0 && numericValue <= 1)
    ? numericValue * 100
    : numericValue;

  // Round to nearest integer to handle floating-point precision
  const rounded: number = Math.round(normalized);

  // Validate range (0-100)
  if (rounded < 0 || rounded > 100) {
    return {
      retention: null,
      status: "invalid",
      source: "validate",
      message: `Value ${normalized} from ${sourceDescription} is out of valid range (0-100).`
    };
  }

  return {
    retention: rounded,
    status: "ok",
    source: "validate",
    percentText: formatPercent(normalized)
  };
}

/** Formats a number as a percent string without unnecessary rounding */
function formatPercent(value: number): string {
  // Treat near-integers as integers to avoid 92.999999 artifacts
  const epsilon = 1e-6;
  if (Math.abs(value - Math.round(value)) < epsilon) {
    return `${Math.round(value)}%`;
  }
  // Show up to 2 decimal places for readability
  const formatted = Math.round(value * 100) / 100; // two decimals
  return `${formatted}%`;
}

/**
 * Finalizes the result by adding timestamp and optionally logging to worksheet.
 *
 * @param workbook - The Excel workbook
 * @param result - The retention result to finalize
 * @returns Finalized RetentionResult with timestamp
 */
function finalize(
  workbook: ExcelScript.Workbook,
  result: RetentionResult
): RetentionResult {
  // Add ISO 8601 timestamp
  const now: Date = new Date();
  const updatedAtLocal: string = now.toISOString();

  const finalResult: RetentionResult = {
    ...result,
    updatedAtLocal
  };

  // Optional logging to worksheet (always write a status line)
  if (ENABLE_LOGGING) {
    try {
      const wb = workbook as unknown as OSWorkbook;
      let logSheet: OSWorksheet | null = null;
      if (LOG_TO_ACTIVE_SHEET_ONLY) {
        try { logSheet = wb.getActiveWorksheet(); } catch {}
      } else {
        logSheet = wb.getWorksheet(LOG_SHEET);
        if (!logSheet) {
          try { logSheet = wb.addWorksheet(LOG_SHEET); } catch {}
        }
        if (!logSheet) {
          try { logSheet = wb.getActiveWorksheet(); } catch {}
        }
      }
      if (!logSheet) {
        diag(workbook, ["Logging target sheet unavailable; skipping write."]);
        return finalResult;
      }
      // Try to bring the sheet to the foreground for visibility
      try { logSheet.activate(); } catch {}

      const valueRange = logSheet.getRange(LOG_CELL_VALUE);
      const timeRange = logSheet.getRange(LOG_CELL_TIME);
      const percentRange = logSheet.getRange(LOG_CELL_PERCENT);
      if (valueRange) valueRange.setValue(finalResult.retention ?? "N/A");
      if (percentRange) percentRange.setValue(finalResult.percentText ?? "N/A");
      if (timeRange) {
        const statusText = `status=${finalResult.status}`;
        const msgText = finalResult.message ? ` — ${finalResult.message}` : "";
        const sourceText = finalResult.source ? ` — source=${finalResult.source}` : "";
        timeRange.setValue(`${updatedAtLocal} — Created by Andrew Jafuta — ${statusText}${sourceText}${msgText}`);
      }
      // Confirmation diagnostics
      diag(workbook, [
        `Logged output to sheet '${(() => { try { return logSheet.getName(); } catch { return LOG_TO_ACTIVE_SHEET_ONLY ? "(active)" : LOG_SHEET; } })()}' at D2/D3/D4`
      ]);
    } catch (error) {
      // Silently ignore logging failures
      // Don't disrupt the main workflow if logging fails
    }
  }

  return finalResult;
}

/**
 * Case-insensitive string comparison with trimming.
 *
 * @param a - First string to compare
 * @param b - Second string to compare
 * @returns True if strings are equal (case-insensitive), false otherwise
 */
function equalsLoose(a: string, b: string): boolean {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

// ========== DIAGNOSTICS HELPER ==========
function diag(workbook: ExcelScript.Workbook, lines: string[]): void {
  if (!ENABLE_DIAGNOSTICS || !lines || lines.length === 0) return;
  // Log to console (visible in Office Scripts runner)
  try {
    for (const line of lines) {
      // eslint-disable-next-line no-console
      console.log(line);
    }
  } catch {
    // ignore console errors
  }
  if (!DIAG_WRITE_TO_SHEET) return;
  try {
    const wb = workbook as unknown as OSWorkbook;
    let ws = wb.getWorksheet(DIAG_SHEET);
    if (!ws) {
      try { ws = wb.addWorksheet(DIAG_SHEET); } catch {}
    }
    if (!ws) {
      try { ws = wb.getActiveWorksheet(); } catch {}
    }
    if (!ws) {
      return;
    }
    try { ws.activate(); } catch {}
    // Write sequentially starting at DIAG_START_CELL column
    const startRow = Number(DIAG_START_CELL.replace(/[^0-9]/g, "")) || 2;
    const colLetter = DIAG_START_CELL.replace(/[0-9]/g, "") || "E";
    for (let i = 0; i < lines.length; i++) {
      const addr = `${colLetter}${startRow + i}`;
      const cell = ws.getRange(addr);
      if (cell) cell.setValue(lines[i]);
    }
  } catch {
    // ignore sheet write errors
  }
}
